# Resume

## Методы жизненного цикла
[Диаграмма методов](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
Основные методы:
- componentDidMount - вызывается один раз, после того как компонент отрисовался. Как правило вызываем чтобы ПОУЛЧИТЬ данные первый раз при загрузке страницы.
- componentDidUpdate - вызывается каждый раз, после того как компонент обновляется (из-за обновления пропсов и/или обновления стейта). Как правило вызываем чтобы ОБНОВИТЬ данные при изменении каких-либо фильтров (при измении props / state).
- componentWillUnmount - вызывается один раз, перед тем как компонент удалится. Как правило применяем для отписок (если делали подписки в componentDidMount), например от вебсокета или setInterval.
- shouldComponentUpdate -вызывается после каждого обновления перед render. Принимает на вход nextProps и nextState, имеет доступ к текущим this.props и this.state. Должен вернуть true / false для того чтобы продолжить / предотвратить render. Применяем для оптимизации, чтобы исключить лишние ненужные рендеры.

**ВАЖНО!** Все сайд эффекты (например обращения к серверу / localestorage и проч.) делает только в методах этапа commit (см. [диаграмму](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)): componentDidMount / componentDidUpdate / componentWillUnmount.

**ВАЖНО!** Если мы в рамках ```componentDidUpdate``` воспользуемся ```this.setState```, то ```this.setState``` приведет к перерендеру компонента, мы снова попадем в componentDidUpdate и снова вызовем ```this.setState``` и таким образом получим бесконечный цикл. Чтобы такого не случилось надо либо вызывать ```this.setState``` в ```componentDidUpdate``` только по какому-то условию, а не всегда, либо останавливать не нужны обновления через ```shouldComponentUpdate```.

Если мы с целью оптимизации применяем shouldComponentUpdate и все что делаем просто сравниваем старые и новые пропсы, то можно вместо этого унаследовать наш классовые компонент от React.PureComponent вместо React.Component.
React.PureComponent отличается от React.Component тем что сам без нас реализует метод shouldComponentUpdate где и сравнивает пропсы.
Сравнение происходит поверхности и по ссылке. Т.е. если у нас два идентичных по структуре и значениям объекта, но разные по ссылке (например {a: 1} !== {a:1}, т.к. мы тут создали два одинаковых по значению но разных по ссылке объекта) то React.PureComponent пойдет на лишний перендер. В таких случаях надо использоваться React.Component и самому реализовывать shouldComponentUpdate с более сложной проверкой (для примера ваше сравнивать не сами объекты, а их значения поля 'a').


## CSS Modules
В css нет областей видимости переменных как в js, соотв существует проблема, как менеджерить большой объем css селекторов, чтобы они не перезатирали друг друга. Одно из решений css modules, когда webpack во время сборки добавляет уникальный hash постфикс к названиям класса, делая тем самым уникальным все название в рамках проекта.

Для применения css modules нужно:
- название файла должно заканчиваться на .module.css (например styles.module.css)
- импортировать данный css в компонент ```import css from './styles.modules.css'``` для нашего примера
- повесить нужны нам класс на элемент, представим что в нашем css есть класс ```.wrapper```, тогда для нашего прмера навешивать будем так ```<div className={css.wrapper}></div>```


### webpack aliases
для глубоко вложенных элементов имеем импорты вида ```../../../components/common```, что не удобно. Т.к. постоянно надо помнить где находишься в глубине, чтобы корректно их прописать, плюс при рефакторинге и измении глубины придется изменять и импорты. Решением являются алиасы вебпака:

Для этого создаем файл в корне проекта ```jsconfig.json``` со следующим содержимым:
```
{
  "compilerOptions": {
    "baseUrl": "src"
  },
  "include": ["src"]
}
```

Теперь мы можем обращаться ко всем папкам в src через абсолютный импорт, т.е. вместо ```../../../components/common``` писать просто ```components/common```


### Прочее
- Дублирование кода не всегда, но часто плохо. Если код дублируется возможно стоит рассмотреть возможность вынести его в отдельную функцию и использовать ее во всех нужных местах. Например, если у нас все инпуты выглядят одинаково, то вместо того, чтобы писать каждый раз одни и те же стили для каждого инпута, имеет смысл создать common компонент Input, для которого мы один раз зададим стили и будем его переиспользовать
- Большие компоненты - плохо. Их сложно читать, поддерживать, понимать. Хорошо - декомпозировать компоненты на более мелкие сущности.
- Для конкатенации стилей есть библиотека classnames которая уже является стандартом. Установить ее можно компандой ```npm i classnames```
