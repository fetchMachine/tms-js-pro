# GoodShop

## File Structure
TBD

## Base
1. Создать в отдельном репозитории проект с помощью `create-react-app --template typescript` (если не уверены в своих силах, можно делать на js)
2. Убедиться, что в проекте настроены абсолютный импорты (TBD: приложит пример)
3. Установить библиотеки `redux-toolkit`, `react-redux`, `react-router`. Обернуть приложение в провадйеры редакса и роутера

## Стартовая страница
1. Создать компонент `<Menu />` с отображение категорий товаров (TBD: добавить ендпоинт)
2. Создать компонент `<Card />` который выводит информацию о товаре (label, price, img). Все карточки должны быть одинакового размера, независимо от размеров картинки. (TBD: переход на страницу товара)
3. Создать компонент категории товаров `<GoodCategory />` (Название категории + карточки с товарами), который принимает в пропсах одну категории товаров и выводит список товаров данной категории. Название категории выводим в шапку, товары мапим в карточку `<Card />` из п.2
4. Создать компонент `<Footer />` с произвольным текстом внутри.
5. Создать компонент `<Header />`. Должен отображаться на всех роутах. Содержит в себе логотип (ссылка на главную страницу).
7. Создать компонент `<MainPage />`, который выводит все наши выше созданные компоненты (`<Menu />` / `<GoodCategory />` / `<Footer />` / `<Header />`)
    - Для создания структуры разметки использовать компоненты Row и Col из antd (можно сначала написать на обычных дивах и потом перевести на antd)

# Страница категории
1. Создать компонент `<CategoryPage />`, который будет выводить информацию по отдельно взятой категории (переиспользуем уже существующий компонент категории, который у нас на главной странице). Список товаров категории берем с бека по типу, тип получаем из роутов. Если нужная категория не найдена (бек отдаст 404) - выводим сообщение "Категория не найдена, вернуться назад".
2. Слово назад должно быть ссылкой, которая перемещает пользователя назад по истории (получаем историю из хука useHistory и вызываем у нее метод goBack). ```const history = useHistory(); history.goBack();```

## Страница с отдельным товаром
1. Создать компонент `<ProductPage />` доступный по соответствующему роуту, который выводит картинку / цена / название / описание
2. Получаем товар с бека по id из роутов. Если не смогли найти продукт - показываем сообщение "Продукт не найден, вернуться назад".  Слово назад должно быть ссылкой, которая перемещает пользователя назад по истории.
3. Есть кнопка "Положить в корзину": а) если товар еще не в корзине и есть в наличие, то просто кнопка б) если товар еще не в корзине и нет в наличие, то задизейбленная кнопка в) если товар уже в корзине и есть достаточно в количества - показывать кнопки добавления (нельзя добавить больше количества в наличии, при снижении до 0 - заменяется просто кнопкой из п А) г)  если товар уже в корзине и нет достаточного в количества, то подсвечивать ошибкой
4. Есть кнопка посмотреть в наличии в магазинах. По клику - открывать модалку с таблицей всех магазинов и с кол-вом товаров в нем.

## Страница корзины
1. Добавить в `<Header />` ссылку на страницу с корзиной (иконка с кол-вом товаров в корзине)
TBD

## Страница со всеми товарами
0. установить для работы сервера функцию orderBy лодаша: ```npm i lodash.orderby```
1. Создать компонент GoodsPage
2. Выводить его по урлу "/goods"
3. Добавить ссылку на эту страницу в меню или хедер
4. Добавить на страницу GoodsPage таблицу с товарами:
    + Получаем товары с бека с помощью redux-thunk из ручки "/goods" и кладем в редакс
    + Таблица должна иметь пагинацию и опцию выбора кол-ва отображаемых за раз строк (используем для этого квери параметры limit (по умолчанию на беке лимит равен 20) и offset)
    + На странице должны присутствовать фильтры:
        - Текстовый поиск (квери параметр text)
        - Мультиселект выбора категорий (квери параметр categoryTypeIds)
        - Слайдер выбора мин и макс цены от 0 до 1000  (квери параметры  minPrice и maxPrice)
        - При изменении любого фильтра сбрасываем пагинацию на первую страницу
        - При изменении фильтра запрос делать на бек с дебаунс задержкой 1,5с
    + При клике на строку с товаром делаем переход на страницу товара
    + Если фильтр пользователем не установлен - на бек соответствующий квери параметр не шлем
    + Колонку цены и названия можно сортировать (квери параметры sortBy=ПОЛЕ_ПО_КОТОРОМУ_ХОТИМ_СОРТИРОВАТЬ и sortDirection=ASC_ИЛИ_DESC для указания направления по возрастанию или убыванию (по умолчанию бек сортирует по возрастанию), например /goods?sortBy=price&sortDirection=asc).
    + На время загрузки (обновления) данных с бека в таблице показывается лоадер

## Страница логина
1. Создать компонент LoginPage
2. Выводить его по урлу "/login"
3. Добавить в компонент 2 инпута (логин и пароль) и 2 кнопки (войти и зарегистрироваться)
4. Кнопка зарегистрироваться должна вести на страницу "/registration"
5. По нажатию на кнопку войти:
    5.1. Валидация полей - если поле не заполненно показываем под ним сообщение с ошибкой "обязательное поле"
    5.2. Eсли введена парада admin / admin, то показывает успешный Notification (компонент antd) с сообщением "Успешный вход"
    5.3. Иначе под кнопками показываем сообщение об ошибке "неверный пароль или логин"
    5.4. Как только начинает печатать в любом инпуте должна убираться ошибка соответствующего инпута и ошибка под кнопками
6. Добавить в `<Header />` email залогинненого юзера

## Страница Регистрации
1. Делаем страницу RegistrationPage
2. Отображаем ее по роуту "/registration"
3. На странице должны быть поля для заполнения и кнопки "Зарегистрироваться" и "Отмена"
4. Кнопка "Отмена" возвращает на главную страницу
5. Кнопка "Зарегистрироваться" еще раз валидирует все поля и если они валидны - показывает успешный тост "Успешная регистрация" и делает редирект на главную страницу, иначе показывает ошибочный тост "Проверьте корректность заполнения формы"

Для валидации можно использовать библиотеку [yup](https://github.com/jquense/yup). Там много готовых правил валидации и простое в использхование api.

Должны быть следующие поля для заполнения:

| Поле                           | Тип                | Обязательное | Доп правила валидации |
| ------------------------------ | ------------------ | --- | ------------------------------ |
| Имя                            | Текстовы инпут     | Да  | содержит 2+ символа |
| Фамилия                        | Текстовы инпут     | Нет | содержит 2+ символа |
| Почта (будет у нас логином)    | Текстовы инпут     | Да  | либо проверка на наличие "@" и минимум по 2 символа с каждой стороны от него, либо у yup есть валидация на email |
| Пароль / Повторите Пароль      | 2 текстовых инпута | Да  | Оба поля совпадают, не менее 6 символов |
| Пол                            | Радои кнопки       | Нет | - |
| Любимые категории              | Чекбоксы           | Да  | Выбрано минимум 2 категории. Список для чекбоксов брать из "/categories") |
| Выбор подписка на новости      | Свитчер (да / нет) | Да  | - |
| Дата рождения                  | Календарь          | Да  | Не раньше 1 янв 1930 года |
| Секр. вопрос для восст. пароля | 2 инпута (тип вопроса и ответ) | Нет | Если выбран тип - то ответ обязателен, иначе инпут с ответом не показываем |



## Логика поиска для инпута
1. Делаем в `<Header />` инпут с поиском и подсказками. При вводе значения с дебаунсом 1,5с идем на бекенд за товарами, используя для поиска квери параметр text
2. Показываем в дропдауне список из названий товаров, что отдал бек. При клике по товару - переходим на страницу товара.
3. Если ничего не нашлось, то показываем в дропдауне сообщение "Ничего не найдено, попробуйте изменить запрос"

## Авторизационные токены
0. Уставить jsonwebtoken и обновить файл сервера
1. Создать отдельный слайс в редаксе, который будет хранить информацию о юзере (логин / токен / флаг isAuth - по умолчанию false).
2. Форма регистрации в случае валидного заполнения должна делать запрос POST /registration передавая значения формы и в случае успеха (помимо успешного тоста) должна делать редирет на страницу логина. В теле запроса передаем ```{ name, surname, email, password, gender, interests, isSubscribe, secret: { type, answer }, bornAt }```. Если какое-то поле не обязательно и юзер его не заполнил, то на бек его не шлем.
3. Страница логина должна делать запрос POST /login передавая в теле ```{ login, password }```. В случае успеха с бека вернется информация о юзере, которую нужно положить в редакс и localStorage (класть и в стору и в localStorage можно в одной и той же санке). А также установить флаг isAuth=true.
4. При загрузке приложения считываем localStorage в поиске информации о юзере и, если нашли - кладем в редакс.
5. Если юзер не вошел (isAuth=false), то для него доступны ссылки и страницы "Войти" и "Регистрация", корзина не доступна.
6. Если юзер вошел (isAuth=true), то для него доступна корзина, доступна кнопка Выйти. И не доступны ссылки и страницы "Войти" и "Регистрация".
7. Кнопка выйти очищает данные о юзере и сторы и localstorage и устанавливает флаг isAuth=false.
8. Работа с корзиной теперь доступна лишь для зарегистрированных пользователей, соответственно все запросы надо подписывать токеном.
9. Для удобства работы с токенами желательно применить паттерн синглтон для нашего класса Api [пример на js](./misc/singleton.js) / [пример на ts](./misc/singleton.ts)

## Административная страница добавления / редактирования / удаления товаров
TBD: таблица со всеми товарами и фильтрами + кнопка удаления + модалка на создание и редактоирование

## Прочее
1. Написать минимум 5 тестов для Api. Проверять корректность составления квери параметров и урлов [пример на ts.](./misc/example.test.ts)
2. Применить DI для наших санок.
```typescript
// пример создания
const api = new Api();

export const store = createStore(
  reducer,
  applyMiddleware(thunk.withExtraArgument(api))
)

// пример использования
export const fetchCategories = (params:string) => async (dispatch: Dispatch, _getState: unknown, api: Api) => {
  dispatch(getCategories());

  api.getCategories(params)
    .then((resp) => {
        getCategoriesSuccess(resp)
    })
    .catch(() => {
        dispatch(getCategoriesFailure())
    });
};
```
3. Перевести проект на webpack.
    + Удалить из зависимостей react-scripts ```npm uninstall react-scripts```
    + Отредактировать src/tsconfig.json, изменив noEmit на false ```"noEmit": false,```
    + Отредактировать scripts в pacjakge.json
    ```json
        "scripts": {
        "start": "webpack-dev-server",
        "build": "webpack",
        "test": "jest",
        },
    ```
    + Установить необходимые зависимости ```npm i --save-dev webpack webpack-dev-server webpack-cli```
    + Создаить файл с конфигами src/webpack.config.js и написать конфиги ([пример](./misc/webpack.config.js)).
    + Удостовериться, что все компоненты находятся в tsx файлах.
    + Установить зависимости, которые использовали в конфиге вебпака ```npm i --save-dev style-loader css-loader ts-loader html-webpack-plugin clean-webpack-plugin```
    + Если из-за импортов НЕ js файлов возникают ошибки связанные с отсутсвием лоадеров - поставить необходимые лоадеры.

### Info
asc - ascending - по возрастанию
desc - descending - по убыванию

```javascript
// fetch с подписанным токеном
fetch('/api/cart', headers: { Authorization: `Bearer ${ВАШ_ТОКЕН}` });
```

// пример лоадстатусов
export enum LOAD_STATUSES = {
    UNKNOWN = 'unknown',
    LOADING = 'loading',
    LOADED = 'loaded',
    ERROR = 'error',
}

```typescript
// пример useEffect аналога метода componentDidMount
useEffect(() => {
    dispatch(someAction);
}, [])
```

## DRAFT: Интеграция с бекендом
0. установить miragejs / faker / yup, скорпировать файл [server.js](https://github.com/fetchMachine/tms-js-pro/blob/main/hms/misc/server_shop.js) с моками бека  себе в проект и импортировать в src/index
1. Создать класс, ответственный за коммуникацию с бекендом в src/api/Api. Класс должен содержать методы получения данных для каждого ендпоинта (делать fetch запрос, проверять на ok, делать, вызывать .json() и при необходимости трансформировать данные из структуры что отдал бекенд в удобную для вас структуру). Также тут создаем все интерфейсы и наши методы должны возвращать не any, а типизированные объекты
```javascript
interface Good {
    id: string;
    label: string;
    // ...
}
class Api {
    getGoods(): Promise<{ items: Good[]; total: number }> {
        return fetch('/api/goods').then(r => {
            if (r.ok) {
                return r.json()
            }
        });
    }
}
```
2. Использовать статусы загрузки, чтобы отображать лоадер на время загрузки / сообщение об ошибке (тосты), если запрос провалился

