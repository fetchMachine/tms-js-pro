### Общее
1. Лейаут (Header (Лого + креды + корзина) / Footer / Content)
2. Роутер
3. Redux-toolkit

## Главная страницу
TBD: меню + топ подборки по категориям (переход на страницы отдельно взятого товара) + инпут с поиском

## Страница с отдельным товаром
1. Доступна по соответствующему роуту
2. Отображается информация по товару (
3. Есть кнопка "Положить в корзину": а) если товар еще не в корзине и есть в наличие, то просто кнопка б) если товар еще не в корзине и нет в наличие, то задизейбленная кнопка в) если товар уже в корзине и есть достаточно в количества - показывать кнопки добавления (нельзя добавить больше количества в наличии, при снижении до 0 - заменяется просто кнопкой из п А) г)  если товар уже в корзине и нет достаточного в количества, то подсвечивать ошибкой
4. Есть кнопка посмотреть в наличии в магазинах. По клику - открывать модалку с таблицей всех магазинов и с кол-вом товаров в нем.

## Страница со всеми товарами
0. установить для работы сервера функцию orderBy лодаша: ```npm i lodash.orderby```
1. Создать компонент GoodsPage
2. Выводить его по урлу "/goods"
3. Добавить ссылку на эту страницу в меню или хедер
4. Добавить на страницу GoodsPage таблицу с товарами:
    + Получаем товары с бека с помощью redux-thunk из ручки "/goods" и кладем в редакс
    + Таблица должна иметь пагинацию и опцию выбора кол-ва отображаемых за раз строк (используем для этого квери параметры limit (по умолчанию на беке лимит равен 20) и offset)
    + На странице должны присутствовать фильтры:
        - Текстовый поиск (квери параметр text)
        - Мультиселект выбора категорий (квери параметр categoryTypeIds)
        - Слайдер выбора мин и макс цены от 0 до 1000  (квери параметры  minPrice и maxPrice)
        - При изменении любого фильтра сбрасываем пагинацию на первую страницу
        - При изменении фильтра запрос делать на бек с дебаунс задержкой 1,5с
    + При клике на строку с товаром делаем переход на страницу товара
    + Если фильтр пользователем не установлен - на бек соответствующий квери параметр не шлем
    + Колонку цены и названия можно сортировать (квери параметры sortBy=ПОЛЕ_ПО_КОТОРОМУ_ХОТИМ_СОРТИРОВАТЬ и sortDirection=ASC_ИЛИ_DESC для указания направления по возрастанию или убыванию (по умолчанию бек сортирует по возрастанию), например /goods?sortBy=price&sortDirection=asc).
    + На время загрузки (обновления) данных с бека в таблице показывается лоадер

## Страница логина
1. Создать компонент LoginPage
2. Выводить его по урлу "/login"
3. Добавить в компонент 2 инпута (логин и пароль) и 2 кнопки (войти и зарегистрироваться)
4. Кнопка зарегистрироваться должна вести на страницу "/registration"
5. По нажатию на кнопку войти:
    5.1. Валидация полей - если поле не заполненно показываем под ним сообщение с ошибкой "обязательное поле"
    5.2. Eсли введена парада admin / admin, то показывает успешный Notification (компонент antd) с сообщением "Успешный вход"
    5.3. Иначе под кнопками показываем сообщение об ошибке "неверный пароль или логин"
    5.4. Как только начинает печатать в любом инпуте должна убираться ошибка соответствующего инпута и ошибка под кнопками

## Страница Регистрации
1. Делаем страницу RegistrationPage
2. Отображаем ее по роуту "/registration"
3. На странице должны быть поля для заполнения и кнопки "Зарегистрироваться" и "Отмена"
4. Кнопка "Отмена" возвращает на главную страницу
5. Кнопка "Зарегистрироваться" еще раз валидирует все поля и если они валидны - показывает успешный тост "Успешная регистрация" и делает редирект на главную страницу, иначе показывает ошибочный тост "Проверьте корректность заполнения формы"

Для валидации можно использовать библиотеку [yup](https://github.com/jquense/yup). Там много готовых правил валидации и простое в использхование api.

Должны быть следующие поля для заполнения:

| Поле                           | Тип                | Обязательное | Доп правила валидации |
| ------------------------------ | ------------------ | --- | ------------------------------ |
| Имя                            | Текстовы инпут     | Да  | содержит 2+ символа |
| Фамилия                        | Текстовы инпут     | Нет | содержит 2+ символа |
| Почта (будет у нас логином)    | Текстовы инпут     | Да  | либо проверка на наличие "@" и минимум по 2 символа с каждой стороны от него, либо у yup есть валидация на email |
| Пароль / Повторите Пароль      | 2 текстовых инпута | Да  | Оба поля совпадают, не менее 6 символов |
| Пол                            | Радои кнопки       | Нет | - |
| Любимые категории              | Чекбоксы           | Да  | Выбрано минимум 2 категории. Список для чекбоксов брать из "/categories") |
| Выбор подписка на новости      | Свитчер (да / нет) | Да  | - |
| Дата рождения                  | Календарь          | Да  | Не раньше 1 янв 1930 года |
| Секр. вопрос для восст. пароля | 2 инпута (тип вопроса и ответ) | Нет | Если выбран тип - то ответ обязателен, иначе инпут с ответом не показываем |



## Логика поиска для инпута
1. Делаем дропдаун с поиском. При вводе значения с дебаунсом 1,5с идем на бекенд за товарами, используя для поиска квери параметр text
2. Показываем в дропдауне список из названий товаров, что отдал бек. При клике по товару - переходим на страницу товара.
3. Если ничего не нашлось, то показываем в дропдауне сообщение "Ничего не найдено, попробуйте изменить запрос"

## Авторизационные токены
0. Уставить jsonwebtoken и обновить файл сервера
1. Создать отдельный слайс в редаксе, который будет хранить информацию о юзере (логин / токен / флаг isAuth - по умолчанию false).
2. Форма регистрации в случае валидного заполнения должна делать запрос POST /registration передавая значения формы и в случае успеха (помимо успешного тоста) должна делать редирет на страницу логина. В теле запроса передаем ```{ name, surname, email, password, gender, interests, isSubscribe, secret: { type, answer }, bornAt }```. Если какое-то поле не обязательно и юзер его не заполнил, то на бек его не шлем.
3. Страница логина должна делать запрос POST /login передавая в теле ```{ login, password }```. В случае успеха с бека вернется информация о юзере, которую нужно положить в редакс и localStorage (класть и в стору и в localStorage можно в одной и той же санке). А также установить флаг isAuth=true.
4. При загрузке приложения считываем localStorage в поиске информации о юзере и, если нашли - кладем в редакс.
5. Если юзер не вошел (isAuth=false), то для него доступны ссылки и страницы "Войти" и "Регистрация", корзина не доступна.
6. Если юзер вошел (isAuth=true), то для него доступна корзина, доступна кнопка Выйти. И не доступны ссылки и страницы "Войти" и "Регистрация".
7. Кнопка выйти очищает данные о юзере и сторы и localstorage и устанавливает флаг isAuth=false.
8. Работа с корзиной теперь доступна лишь для зарегистрированных пользователей, соответственно все запросы надо подписывать токеном.
9. Для удобства работы с токенами желательно применить паттерн синглтон для нашего класса Api [пример на js](./misc/singleton.js) / [пример на ts](./misc/singleton.ts)

## Административная страница добавления / редактирования / удаления товаров
TBD: таблица со всеми товарами и фильтрами + кнопка удаления + модалка на создание и редактоирование

## Прочее
1. Написать минимум 5 тестов для Api. Проверять корректность составления квери параметров и урлов [пример на ts.](./misc/example.test.ts)
2. Применить DI для наших санок.
```typescript
// пример создания
const api = new Api();

export const store = createStore(
  reducer,
  applyMiddleware(thunk.withExtraArgument(api))
)

// пример использования
export const fetchCategories = (params:string) => async (dispatch: Dispatch, _getState: unknown, api: Api) => {
  dispatch(getCategories());

  api.getCategories(params)
    .then((resp) => {
        getCategoriesSuccess(resp)
    })
    .catch(() => {
        dispatch(getCategoriesFailure())
    });
};
```
3. Перевести проект на webpack.
    + Удалить из зависимостей react-scripts ```npm uninstall react-scripts```
    + Отредактировать src/tsconfig.json, изменив noEmit на false ```"noEmit": false,```
    + Отредактировать scripts в pacjakge.json
    ```json
        "scripts": {
        "start": "webpack-dev-server",
        "build": "webpack",
        "test": "jest",
        },
    ```
    + Установить необходимые зависимости ```npm i --save-dev webpack webpack-dev-server webpack-cli```
    + Создаить файл с конфигами src/webpack.config.js и написать конфиги ([пример](./misc/webpack.config.js)).
    + Удостовериться, что все компоненты находятся в tsx файлах.
    + Установить зависимости, которые использовали в конфиге вебпака ```npm i --save-dev style-loader css-loader ts-loader html-webpack-plugin clean-webpack-plugin```
    + Если из-за импортов НЕ js файлов возникают ошибки связанные с отсутсвием лоадеров - поставить необходимые лоадеры.

### Info
asc - ascending - по возрастанию
desc - descending - по убыванию

```javascript
// fetch с подписанным токеном
fetch('/api/cart', headers: { Authorization: `Bearer ${ВАШ_ТОКЕН}` });
```

---
# Draft

# GoodsShop
1. Создать в отдельном репозитории проект с помощью creatre-react-app --template typescript (если не уверены в своих силах, можно делать на js)
2. Создать компонент Menu используя antd, который принимает в пропсах пункты меню (создать список самому согласно структуре categories) и мапит его в список ссылок
    - Пример пункта меню ```<li><a href="#">{title}</a></li>```
    - Структура пунктов меню ```const categories = [{ id: 1, type: 'house', label: 'Дом' }]; ```
3. Создать компонент Card с помощью antd (можно сначала попробовать сделать обычном html и потом переделать на antd), который принимает в пропсы товар ```const good = { id: 1, category_type: 'house', label: 'Коврик', price: 99, img: 'https://source.unsplash.com/random'  }```. Все карточки должны быть одинакового размера, независимо от размеров картинки.
4. Создать компонент категории товаров <GoodCategory /> (Название категории + карточки с товарами), который принимает в пропсах одну категории товаров. Название категории выводим в шапку, товары мапим в карточку из п.2
    - Структура категорий товаров ```const goodCategory = { category:{ id: 1, type: 'house', label: 'Дом' }, items: [{ id: 1, category_type: 'house', label: 'Коврик', price: 99, img: 'https://source.unsplash.com/random'  }]  }; ```
5. Создать компонент `<Footer />` с произвольным текстом внутри (Footer)
6. Создать компонент `<MainPage />`, который выводит все наши выше созданные компоненты (меню / категории товаров / футер) и прокидывает необходимые им пропсы
    - Прокидывает пункты меню в <Menu />
    - Мапит популярные категории (создать самому согласно структуре popularCategories), прокидывая каждую категорию в <GoodCategory /> `const popularCategories = [{ category:{ id: 1, type: 'house', label: 'Дом' }, items: [{ id: 1, category_type: 'house', label: 'Коврик', price: 99, img: 'https://source.unsplash.com/random'  }]  }]; `
    - Для создания структуры разметки использовать компоненты Row и Col из antd (можно сначала написать на обычных дивах и потом перевести на antd)
7. Подключить роутинг (выводит единственный компонент <MainPage /> для любого роута)
    - Установить react-router-dom
    - Обернуть все приложение Router (см п.1 резюме react-router)
    - Добавить один единственный роут на нашу страницу <MainPage /> для любого урла ```path="/"``` (см п.3в резюме react-router)
    - Заменить тег <a> на компонент <Link /> в нашем <Menu /> (см п.2 резюме react-router)
8. Подключить redux и перенести в его initialState popularCategories и categories из <MainPage />
    - [базовый пример](https://codesandbox.io/s/xenodochial-mendel-iwhpb)
    - Установить библиотеки redux и react-redux
    - создать редюсер возвращающий initialState ```const initialState = { popularCategories, categories }``` (см src/store/reducer примера)
    - создать стору (createStore) используя редюсер и обернуть все приложение в провайдер используя наш стору ```<Provider store={store}><App /></Provider> ``` (см src/index примера)
    - Написать селекторы для получения popularCategories и categories соответвующих данных из сторы (см src/store/selectors примера)
    - Изменить компонент <Menu />, теперь он должен получать пункты меню не из пропсов, а из редакса используя хук useSelector и написанный нами селектор (см src/App примера)
    - Изменить компонент <MainPage />, теперь он должен получать popularCategories, из редакса используя хук useSelector и написанный нами селектор (см src/App примера)

 # Next
1. Создать компонент CategoryPage, который будет выводить информацию по отдельно взятой категории (переиспользуем уже существующий компонент категории, который у нас на главной странице). Нужную категорию он должен из урла с помощью хука ```useParams```. Если нужная категория не найдена в массиве категорий (ищем по типу в массиве categories: categories.find(el => el.type === ИСКАМАЯ_КАТЕГОРИЯ) - выводим сообщение "Категория не найдена, вернуться назад".
2. Слово назад должно быть ссылкой, которая перемещает пользователя назад по истории (получаем историю из хука useHistory и вызываем у нее метод goBack). ```const history = useHistory(); history.goBack();```
3. Добавить в наши роуты динамический роут для  CategoryPage ```<Route path="/:type" element={CategoryPage} />```
4. Создать компонент ProductPage, который выводит картинку / цена / название / описание (добавить поле description в наши константы продукта) продукта. Если не смогли найти продукт - показываем сообщение "Продукт не найден, вернуться назад".  Слово назад должно быть ссылкой, которая перемещает пользователя назад по истории.
5. Добавить в наши роуты динамический роут для  ProductPage ```<Route path="/:type/:id element={ProductPage} />```. Поместить этот роут на строчку выше роута для CategoryPage.
6. Изменить ссылке в нашем пеню, теперь они должны вести на страницу категории ```<Link to={`/${type}`}> ```
7. Карточки с продуктом должны быть ссылками и при клике должны вести на страницу продукта ```<Link to={`/${type}/${product.id}`}> ```

## Интеграция с бекендом
0. установить miragejs / faker / yup, скорпировать файл [server.js](https://github.com/fetchMachine/tms-js-pro/blob/main/hms/misc/server_shop.js) с моками бека  себе в проект и импортировать в src/index
1. Создать класс, ответственный за коммуникацию с бекендом в src/api/Api. Класс должен содержать методы получения данных для каждого ендпоинта (делать fetch запрос, проверять на ok, делать, вызывать .json() и при необходимости трансформировать данные из структуры что отдал бекенд в удобную для вас структуру). Также тут создаем все интерфейсы и наши методы должны возвращать не any, а типизированные объекты
```javascript
interface Good {
    id: string;
    label: string;
    // ...
}
class Api {
    getGoods(): Promise<{ items: Good[]; total: number }> {
        return fetch('/api/goods').then(r => {
            if (r.ok) {
                return r.json()
            }
        });
    }
}
```

2. Создать отдельный слайс в сторе для корзины используя combineReducer.

3. Создать компонент HEADER.  1) Должен отображаться на всех роутах (Footer тоже, если еще не) 2) Должен иметь логотип ссылку на главную страницу "/" 3) Должен иметь инпут, пока без какой-либо логики 4) Должен иметь корзину (кнопку или картинку), которая при наличии товаров в ней должна отобразить бейдж с кол-вом товаров (Используем гет запрос по урлу "api/cart" на маутинге компонента, чтобы получить и положить корзину в стору).

4. Используя redux-thunk связать меню с беком. Удалить существующие моки категория для меню, на маунтинге меню (использовать useEffect) запросить данные с бека (```fetch('/api/categories')```), использовать статусы загрузки, чтобы отображать лоадер на время загрузки / сообщение об ошибке, если запрос провалился.
5. Используя redux-thunk связать с беком популярные категории (на маутинге страницы популярных категорий делать гет запрос по урлу "api/popular_categories")
6. Связать страницу категории, используя redux-thunk, делаем два гет запроса: получаем категорию гет запросом "/api/categories?ids=ID_КАТЕГОРИИ" и товары этой категории гет запросом "/api/goods?categoryTypeIds=ID_КАТЕГОРИИ". Для выполнения двух запросов параллельно в идеале использовать [Promise.all](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
7. Связать страницу продукта, используя redux-thunk и гет запрос "/api/goods?ids=ID_ПРОДУКТА"
8. Удалить все моки из проекта (продукты / категории), теперь у нас все приходит с бека.
9. На странице продукта сделать кнопку добавления / удаления продукта в корзину (используя redux-thunk). Если продукта нет в корзине - добавляем (делаем put запрос по урлу "api/cart", в body передаем весь продукт), если товар уже в корзине - удаляем (делаем delete запрос по урлу "api/cart", в body передаем весь продукт). После добавления / удаления товара должен обновляться счетчик товаров корзины (для этого в случае успешного добавления / удаления снова перепрашиваем корзину). На время запроса к беку кнопку задизейблить

## Misc
```typescript
// пример лоадстатусов
export enum LOAD_STATUSES = {
    UNKNOWN = 'unknown',
    LOADING = 'loading',
    LOADED = 'loaded',
    ERROR = 'error',
}
```

```typescript
// пример useEffect аналога метода componentDidMount
useEffect(() => {
    dispatch(someAction);
}, [])
```
