# Resume

## Error Boundary
- В реакт компонентах, как и в обычном JS коде могут возникать ошибки. В обычном JS мы обрабатываем ошибки через конструкцию try / catch. В реакте для обработки ошибок используется концепция Error Boundary.
- Ошибки в реакт приложении всплывают как и ошибки в обычном JS. Т.е. ошибка поднимается из компонента, в котором она возникла вверх по дереву приложения до тех пор, пока не будет отловлена через Error Boundary.
- Если ошибка так и не была отловлена и поднялась до ReactDom.render, то все приложение упадет. Падает все приложение из-за ошибки даже в одном компоненте, чтобы не получить неконсистентное состояние (рассинхронизация состояния между компонентом где произошла ошибка и остальным приложением).
- Если мы понимаем, что у нас есть часть приложения, не связанная с основным контентом и ошибки в нем не аффектят основное приложение, то мы можем обернуть его в Error Boundary и в случае возникновения ошибки в не показывать запасной ui заглушку.
- Error Boundary - компонент с методами жизненного цикла ```static getDerivedStateFromError``` и ```componentDidCatch```, которые срабатывают при возникновении ошибок у его **детей**
- ```static getDerivedStateFromError``` - метод фазы рендер, т.е. здесь **нельзя** делать сайд эффекты (сетевые запросы), служит для включения флага отображения запасного ui
- ```componentDidCatch``` - метод фазы commit, тут можно и нужно делать сайд эффекты (например, после того как возникла ошибка отравить отчет об ошибке на бекенд)

```javascript
class ErrorBoundary extends React.Component {
    // начальное состояние - ошибки нет
    state = { isError: false };

  // getDerivedStateFromError возвращает следующее значение state
  static getDerivedStateFromError(error) {
    // в случае если произошла ошибка - вешаем флаг в true
    return { isError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Если надо, отправляем отчет об ошибке на бекенд
    fetch('someSiteUrl', errorInfo);
  }

  render() {
    if (this.state.isError) {
      // Если ошибка - показываем запасной ui
      return <div>Что-то пошло не так.</div>;
    }

    // если ошибки нет - показываем детей
    return this.props.children;
  }
}

const App = () => {
    return (
        <ErrorBoundary>
            <SomeComponentWithPotentialError />
        </ErrorBoundary>
    );
}
```

## Refs
TBD (рефа + forwardred + на класс)

## Fragments
- Компонент должен возвращать один единственный элемент.
- Если нам надо вернуть более одного элемента, то мы оборачиваем их в div. Но это не всегда удобно / возможно, что может стать проблемой.
- Ранее для этого использовались массивы, современный подход - Фрагменты.
- Фрагмент оборачивает react элементы, чтобы выполнить правило возврата не более одного элемента и в реальный DOM никак не вставляется.

```javascript
const Component = () => {
    return (
        {/* Используем фрагмент чтобы обернуть и вернуть сразу 2 дива */}
        {/* React.Fragment может принимать только один пропс - key, который нужен, если мы используем фрагмент во время маппинга */}
        <React.Fragment key>
            <div />
            <div />
        </React.Fragment>
    );
}

const Component = () => {
    return (
        {/* Краткая запись фрагмента, в краткую запись нельзя прокидывать key */}
        <>
            <div />
            <div />
        </>
    );
}
```

## PropTypes
TBD

## Порталы
- Порталы используются чтобы отрендерить элемент в произвольное место DOM, наиболее частый кейс использования рендер всего что всплывает (модалки, тосты, тултипы и тд)
- Портал - компонент, который вместо разметки возвращает ReactDOM.createPortal(component, container)
- Несмотря на то, что рендерим мы его в произвольное место в DOM, вся логика (всплытие евентов, например) будет работать согласно иерархии React дерева.

```javascript
// компонент-портал, который рендерит своих детей в body
const BodyPortal = ({ children }) => {
    const body = document.querySelector('body');

    return ReactDOM.createPortal(children, body);
}
```
